# sensible-fitting roadmap / improvements

This file tracks planned changes and design decisions for `sensible-fitting`.
The library is not yet used in production, so breaking changes are acceptable, but
the goal is a stable v1 API.

## Design goals

- Sensible defaults for common AMO workflows (one-liners for the common case).
- Immutable/builder-style `Model` API (no hidden mutable state).
- Seeding is first-class and debuggable (`optimise=False`, `Run.predict(which="seed")`).
- Consistent results/uncertainties across backends.
- Lightweight core dependencies; heavy/optional backends behind extras.

## Done

- Correlated uncertainties via covariance (`ParamView.u` / `MultiParamView.u`).
- Plotting helper (`sensible_fitting.viz.plot_fit`).
- Core tests + example smoke tests.

## Next (priority order)

1. High-level plotting sugar (keep low-level helper)
   - Add `Run.plot(...)` (or `viz.plot_run(run, ...)`) that:
     - uses `run.data` to infer `x/y/yerr` for `data_format="normal"` when possible,
     - refuses batched runs unless sliced (`run[i].plot(...)`),
     - forwards styling knobs to `viz.plot_fit` for power users.

2. `scipy.optimize.least_squares` backend for `data_format="normal"`
   - Enables robust losses (`loss="soft_l1"/"huber"/"cauchy"/...`).
   - Operates in residual space (more natural composition for global fits).
   - Expose key SciPy knobs via `backend_options` (e.g. `loss`, `f_scale`, `jac`,
     `diff_step`, `max_nfev`, `workers`, `bounds`).

3. Jacobian support on `Model`
   - Add `Model.jac(jac_fn)` (builder) to attach an analytic Jacobian.
   - Use it in the `least_squares` backend (and optionally pass through to
     `curve_fit` where supported).
   - When no Jacobian is provided, rely on SciPy finite differences (do not make
     autodiff a hard dependency).

4. Resolve `parallel=` in `Model.fit`
   - Either implement parallel fitting over independent datasets, or remove the
     argument to avoid a misleading API surface.

5. Dependency hygiene / packaging
   - Fix `pyproject.toml` metadata (description).
   - Move heavy deps behind extras (likely `ultranest` (+ `h5py`), maybe
     `uncertainties`) and keep core minimal (`numpy`, `scipy`).

6. Priors as optional MAP penalties (minimal, explicit)
   - Keep `Model.prior(...)` for Bayesian backends.
   - Optionally reuse priors as a penalty term for `scipy.minimize` /
     `least_squares` (MAP) behind an explicit flag; default remains MLE.
   - Avoid a general constraint-expression system; keep scope small.

7. Bayesian reporting improvements
   - Expose posterior summaries beyond mean/stderr (median and quantiles) for
     `ultranest`.
   - Make storage of large posterior objects configurable (avoid always storing
     full samples/results for big runs).

8. “Next best point” / sequential design helpers
   - Add `Run.suggest_next_x(candidates, method="auto", objective=..., noise=...)`.
   - Start with simple objectives (max predictive width), then add Fisher/A-opt/
     D-opt modes when Jacobians are available.
   - Provide a generic `design.suggest_next_x(predictor=...)` hook so Gaussian
     processes (and other predictors) can plug in without special-casing.

9. Serialization / reproducibility
   - Add `Run.to_dict()` / `Run.from_dict()` for lightweight persistence.
   - Optional HDF5 support can live behind an extra.

10. More built-in models + seeders
   - Expand `sensible_fitting.models` with common AMO shapes and robust guessers.

## Open questions (need explicit decisions)

- Do backends stay “fit one dataset” (`fit_one`) or evolve to “fit a batch”
  (`fit_batch`) to enable global fits / better performance?
- What is the long-term story for non-Gaussian likelihoods (binomial/beta) and
  robust losses (residual-space vs loglike-space)?
- Should `Run` always retain the original data payloads (current default) or
  make this optional to reduce memory usage?

## Non-goals (for now)

- General expression-based constraints (e.g. `"a = 0.1*b"`) or symbolic tying.
- Peak-list matching likelihoods (permutation-invariant feature assignment);
  treat as an advanced add-on (fit full traces instead when possible).
